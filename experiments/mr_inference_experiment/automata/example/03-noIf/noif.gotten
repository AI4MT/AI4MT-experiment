metamodel dfa "/dfa.gotten/model/DFAAutomaton.ecore" with x1, x2
models "/dfa.gotten/model/dfamodels"
metamodel word "/dfa.gotten/model/DFAWord.ecore" with w1, w2
models "/dfa.gotten/model/wmodels"

dfa input Features {
}

word input Features {
}

output Features {
   Result : Boolean
}

Processor {
	Name : String
	Version : String	
}

MetamorphicRelations {
	// if the final state sets of two automata are disjoint and one of the two automata accepts a word, the other automata must reject it, and vice-versa 
	MR1 = [((States(x1)->excludingAll(FinalStates(x1)))->equals(FinalStates(x2))) 
		implies ( (Result(x1, w1) and not Result(x2, w1) ) or ( not Result(x1, w1) and Result(x2, w1)) )
	]

	// if a first automaton differs from a second automaton only by having a subset of final states
	    // then any word accepted by the first automaton must also be accepted by the second one
	MR2 = [	( FinalStates(x2)->includesAll(FinalStates(x1)) ) implies ( (not Result(x1, w1)) or (Result(x2, w1)) ) ]    

	// if the number of transitions in the first automaton is greater than in the second, then the first automaton should not accept fewer words than the second
	MR3 = [ (Transitions(x1)->size() > Transitions(x2)->size()) implies (Result(x1, w1) or Result(x2, w1)) ]

	// if the initial state of the first automaton is final and the second is not, then the first automaton must accept at least one word that the second does not
	MR4 = [ (InitialState(x1).isFinal and not InitialState(x2).isFinal) implies (Result(x1, w1) and not Result(x2, w1)) ]

	// if both automata have the same initial state, then they should accept the same words
	MR5 = [ (InitialState(x1)->equals(InitialState(x2))) implies (Result(x1, w1) = Result(x2, w1)) ]

	// if the first automaton has unique final states and the second does not, then the first should accept a word that the second does not
	MR6 = [ (UniqueFinal(x1) and not UniqueFinal(x2)) implies (Result(x1, w1) and not Result(x2, w1)) ]
}

