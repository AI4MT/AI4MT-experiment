metamodel dfa "/dfa.gotten/model/DFAAutomaton.ecore" with x1, x2
models "/dfa.gotten/model/dfamodels"
metamodel word "/dfa.gotten/model/DFAWord.ecore" with w1, w2
models "/dfa.gotten/model/wmodels"

dfa input Features {
    NonFinalStates(x1) : Int
    NonFinalStates(x2) : Int
    InitialState(x1) : String
    InitialState(x2) : String
    UniqueFinal(x1) : Boolean
    UniqueFinal(x2) : Boolean
}

word input Features {
}

output Features {
   Result : Boolean
}

Processor {
	Name : String
	Version : String	
}

MetamorphicRelations {
	// if the final state sets of two automata are disjoint and one of the two automata accepts a word, the other automata must reject it, and vice-versa 
	MR1 = [((States(x1)->excludingAll(FinalStates(x1)))->equals(FinalStates(x2))) 
		implies ( (Result(x1, w1) and not Result(x2, w1) ) or ( not Result(x1, w1) and Result(x2, w1)) )
	]

	// if a first automaton differs from a second automaton only by having a subset of final states
	    // then any word accepted by the first automaton must also be accepted by the second one
	MR2 = [	( FinalStates(x2)->includesAll(FinalStates(x1)) ) implies ( (not Result(x1, w1)) or (Result(x2, w1)) ) ]    

	// if both automata have the same initial state, they should accept the same words
	MR3 = [ (InitialState(x1)->equals(InitialState(x2))) implies (Result(x1, w1) = Result(x2, w1)) ]

	// if the number of non-final states in the first automaton is greater than in the second,
	// then the first automaton should have a more complex structure, potentially leading to longer processing time
	MR4 = [ (NonFinalStates(x1) > NonFinalStates(x2)) implies (Result(x1, w1) or not Result(x2, w1)) ]

	// if one automaton has a unique final state and the other does not, 
	// the one with the unique final state should accept fewer words
	MR5 = [ (UniqueFinal(x1) and not UniqueFinal(x2)) implies (not Result(x1, w1) or Result(x2, w1)) ]

	// if both automata have the same number of transitions, they should exhibit similar acceptance behavior for the same input
	MR6 = [ (Transitions(x1)->size() = Transitions(x2)->size()) implies (Result(x1, w1) = Result(x2, w1)) ]
}

