metamodel dfa "/dfa.gotten/model/DFAAutomaton.ecore" with x1, x2
models "/dfa.gotten/model/dfamodels"
metamodel word "/dfa.gotten/model/DFAWord.ecore" with w1, w2
models "/dfa.gotten/model/wmodels"

word input Features {
	context Words def: Word: List = symbol
	context Words def: Automata: List = automata
	context Words def: Accept: List = accept
}

output Features {
   Result : Boolean
}

Processor {
	Name : String
	Version : String	
}

MetamorphicRelations {
	// if the automata accepts the words ending in '0' and we have a second word that appends '1' to any word ending in '0' 
	// then the automata accepts the word ending in '0' and rejects the word ending in '1' 
	MR1 = [ ((Word(w1)->last() == '0') and ((Word(w1)->including('1'))->equals(Word(w2)))) 	implies ( Result(x1, w1) and not Result(x1, w2))]

	// if a word with length at least 2 ends in the symbol '0' and a second word is obtained by removing the first symbol of the first one, then both words must be accepted
	MR2 = [ ((Word(w1)->size() > 1) and (Word(w1)->last() == '0') and ((Word(w1)->remove(0))->equals(Word(w2)))) implies (Result(x1, w1) and Result(x1, w2))]

	// if the automaton accepts a word and we append a symbol that is not in the automaton's alphabet, the new word should not be accepted
	MR3 = [ (Result(x1, w1) and (Word(w1)->last() != (Word(w2)->symbol))) implies not Result(x1, w2)]

	// if a word is accepted by the automaton, then any word that is a prefix of it should also be accepted
	MR4 = [ (Result(x1, w1) and (Word(w2)->symbol->includesAll(Word(w1)->symbol->subList(0, Word(w1)->size() - 1))) ) implies Result(x1, w2)]

	// if two words are accepted by the automaton and they differ by one symbol, then the automaton should accept at least one of them
	MR5 = [ (Result(x1, w1) and Result(x1, w2) and (Word(w1)->symbol->excludingAll(Word(w2)->symbol)->size() == 1)) implies (Result(x1, w1) or Result(x1, w2))]

	// if a word is accepted and we create a new word by duplicating it, the new word should also be accepted
	MR6 = [ (Result(x1, w1) and (Word(w2)->symbol->equals(Word(w1)->symbol->concat(Word(w1)->symbol))) ) implies Result(x1, w2)]
}
